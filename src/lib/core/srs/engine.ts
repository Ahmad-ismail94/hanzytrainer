export type Result='again'|'hard'|'good'|'easy';export interface SRSState{card_id:string;interval:number;ease:number;due_ts:number;error_weight:number;}export function initState(card_id:string,now=Date.now()):SRSState{return{card_id,interval:1,ease:2.3,due_ts:now,error_weight:0}}export function updateState(state:SRSState,result:Result,errors=0,now=Date.now()):SRSState{let{interval,ease,error_weight}=state;switch(result){case'again':ease=Math.max(1.3,ease-0.2);interval=1;error_weight+=Math.max(1,errors);break;case'hard':ease=Math.max(1.3,ease-0.05);interval=Math.max(1,Math.round(interval*1.2));error_weight+=Math.max(0,errors);break;case'good':interval=Math.max(1,Math.round(interval*ease));error_weight=Math.max(0,error_weight-1);break;case'easy':ease=Math.min(2.6,ease+0.05);interval=Math.max(1,Math.round(interval*(ease+0.15)));error_weight=Math.max(0,error_weight-2);break}const due_ts=now+interval*86400000;return{...state,interval,ease,error_weight,due_ts}}export function sortQueue(states:SRSState[],now=Date.now()):SRSState[]{return states.filter(s=>s.due_ts<=now+2*86400000).sort((a,b)=>a.due_ts-b.due_ts||b.error_weight-a.error_weight)}