export type Point=[number,number];function perpendicularDistance(p:Point,a:Point,b:Point){const num=Math.abs((b[0]-a[0])*(a[1]-p[1])-(a[0]-p[0])*(b[1]-a[1]));const den=Math.hypot(b[0]-a[0],b[1]-a[1])||1e-9;return num/den;}export function rdp(points:Point[],epsilon=0.005){if(points.length<3)return points.slice();let dmax=0,index=0;const end=points.length-1;for(let i=1;i<end;i++){const d=perpendicularDistance(points[i],points[0],points[end]);if(d>dmax){index=i;dmax=d}}if(dmax>epsilon){const rec1=rdp(points.slice(0,index+1),epsilon);const rec2=rdp(points.slice(index,points.length),epsilon);return rec1.slice(0,-1).concat(rec2)}else{return[points[0],points[end]]}}export function normalize(points:Point[],padding=0.05){const xs=points.map(p=>p[0]);const ys=points.map(p=>p[1]);const minX=Math.min(...xs),maxX=Math.max(...xs);const minY=Math.min(...ys),maxY=Math.max(...ys);const w=(maxX-minX)||1e-9;const h=(maxY-minY)||1e-9;return points.map(p=>[padding+(p[0]-minX)/w*(1-2*padding),padding+(p[1]-minY)/h*(1-2*padding)] as Point)}export function resample(points:Point[],n=64){if(points.length===0)return[];if(points.length===1)return Array(n).fill(points[0]);const out:Point[]=[];const lengths:number[]=[];let total=0;for(let k=0;k<points.length-1;k++){const l=Math.hypot(points[k+1][0]-points[k][0],points[k+1][1]-points[k][1]);lengths.push(l);total+=l}for(let j=0;j<n;j++){const target=j/(n-1)*total;let acc=0,k=0;while(k<lengths.length&&acc+lengths[k]<target){acc+=lengths[k];k++}const remain=target-acc;const ratio=lengths[k]?remain/lengths[k]:0;const a=points[k],b=points[k+1]||points[k];out.push([a[0]+(b[0]-a[0])*ratio,a[1]+(b[1]-a[1])*ratio])}return out}